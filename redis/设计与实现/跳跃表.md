# redis 跳跃表(skiplist)的实现

## 什么是跳跃表?

### 跳跃表的本质

skiplist本质上也是一种 **查找结构**，用于解决算法中的查找问题,即根据给定的key,快速查到它所在的位置（或者对应的value）。

查找问题解决方法一般分为两大类 : 基于 **各种平衡树** 或者基于 **哈希表**, 但skiplist却比较特殊，它没法归属到这两大类里面。

## 数据结构简介

### 普通有序列表

skiplist，顾名思义，首先它是一个list。实际上，它是在有序链表的基础上发展起来的。

我们先来看一个有序链表，如下图（最左侧的灰色节点表示一个空的头结点）

![有序链表](/img/跳跃表/有序链表.png)

在这样一个链表中，如果我们要查找某个数据，那么需要从头开始 **逐个进行比较**，直到找到包含数据的那个节点，或者找到第一个比给定数据大的节点为止（没找到）。也就是说， **时间复杂度为O(n)**。同样，当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置。

**普通有序列表的第一次演变**

假如我们 **每相邻两个节点增加一个指针**，让 **指针指向下下个节点**，如下图：

![有序列表一次增加指针](/img/跳跃表/有序列表一次增加指针.png)

新增加的指针连成了一个新的链表，但它包含的节点个数只有 **原来的一半**（上图中是7, 19, 26）。现在当我们想查找数据的时候，可以先沿着这个新链表进行查找。当碰到比待查数据大的节点时，再回到原来的链表中进行查找。比如，我们想查找23，查找的路径是沿着下图中标红的指针所指向的方向进行的：

![有序列表一次增加指针查找过程](/img/跳跃表/有序列表一次增加指针查找过程.png)

查找过程如下:

- 23首先和7比较，再和19比较，比它们都大，继续向后比较。
- 但23和26比较的时候，比26要小，因此回到下面的链表（原链表），与22比较。
- 23比22要大，沿下面的指针继续向后和26比较。23比26小，说明待查数据23在原链表中不存在，而且它的插入位置应该在22和26之间。

在这个查找过程中，由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较。 **需要比较的节点数大概只有原来的一半**。

### 普通有序列表的第二次演变

利用同样的方式，我们可以在上层新产生的链表上，继续为每相邻的两个节点增加一个指针，从而产生第三层链表。如下图：

![有序列表二次增加指针](/img/跳跃表/有序列表二次增加指针.png)

依旧查找23, 查找步骤如下:

- 沿着最上层链表首先要比较的是19，发现23比19大
- 最上层指针19指向null,指针降级,继续查找,发现下一个数字为26,大于23
- 指针再次降级, 下一个数字为22, 在下一个数字为26,大于23
- 已无更低纬度指针，所以查询结果为 23 不存在,插入他的位置应该在 22 和 26之间

可以想象，当链表足够长的时候，这种多层链表的查找方式能让我们 **跳过很多下层节点**，大大加快查找的速度。

### 演变至redis的skiplist

skiplist正是受这种 **多层链表** 的想法的启发而设计出来的。

按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常 **类似于一个二分查找**，使得查找的时间复杂度可以降低到 **(log n)**。

但是新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。

skiplist为了避免这一问题，它 **不要求上下相邻两层链表之间的节点个数有严格的对应关系**，而是为每个节点 **随机出一个层数(level)**。

比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个skiplist的过程:

![skiplist生成过程](/img/跳跃表/skiplist生成过程.png)

从上面的插入过程可以得到如下结论:
- 每一个节点的层数（level）是随机出来的，而且新插入一个节点不会影响其它节点的层数。
- 插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。

跳跃表具有如下特征:
- 除了最下面第1层链表之外，它会产生若干层稀疏的链表
- 高层级链表里面的指针故意跳过了一些节点,而且越高层的链表跳过的节点越多。

已上图为例，查找23的查询路径如下:

![skiplist查找过程](/img/跳跃表/skiplist查找过程.png)

## 生成随机层数的计算公式

> [!NOTE|style:flat|label:问题]
> 节点插入时随机出一个层数，仅仅依靠这样一个简单的随机数操作而构建出来的多层链表结构，能保证它有一个良好的查找性能吗？

执行插入操作时计算随机数的过程，是一个很关键的过程，它对skiplist的统计特性有着很重要的影响。这并 **不是一个普通的服从均匀分布的随机数**，它的计算过程如下：

![随机层数计算公式](/img/跳跃表/随机层数计算公式.png)

- 每个节点肯定都有第1层指针（每个节点都在第1层链表里）
- 如果一个节点有第i层(i>=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。
- 节点最大的层数不允许超过一个最大值，记为MaxLevel。

伪代码如下:
```c
randomLevel()
    level := 1
    // random()返回一个[0...1)的随机数
    while random() < p and level < MaxLevel do
        level := level + 1
    return level
```

> [!TIP|style:flat|label:知识点]
> 在redis的实现中, p = **1/4**, MaxLevel = **32**


## 算法性能分析

### 空间复杂度

节点包含的指针数目，相当于这个算法在空间上的额外开销，可以用来度量空间复杂度。

每个节点所包含的平均指针数目（概率期望）

从生成随机层数的伪代码可得结论 : 产生越高的节点层数，概率越低。定量的分析如下：

- 节点层数至少为1。而大于1的节点层数，满足一个概率分布。
- 节点层数恰好等于1的概率为1-p。
- 节点层数大于等于2的概率为p，而节点层数恰好等于2的概率为p(1-p)。
- 节点层数大于等于3的概率为p2，而节点层数恰好等于3的概率为p2(1-p)。
- 节点层数大于等于4的概率为p3，而节点层数恰好等于4的概率为p3(1-p)。
- ......

因此，一个节点的平均层数（也即包含的平均指针数目），计算如下：
- 当p=1/2时，每个节点所包含的平均指针数目为2
- 当p=1/4时，每个节点所包含的平均指针数目为1.33(这也是Redis里的skiplist实现在空间上的开销)。

### 时间复杂度

计算时间复杂度，主要是计算平均查找长度.查找长度指的是查找路径上跨越的跳数，而查找过程中的比较次数就等于查找长度加1。以前面图中标出的查找23的查找路径为例，从左上角的头结点开始，一直到结点22，查找长度为6。

为了计算查找长度，这里我们需要利用一点小技巧。我们注意到，每个节点插入的时候，它的层数是由随机函数randomLevel()计算出来的，而且随机的计算不依赖于其它节点，每次插入过程都是完全独立的。所以，从统计上来说，一个skiplist结构的形成与节点的插入顺序无关。

这样的话，为了计算查找长度，我们可以将查找过程倒过来看，从右下方第1层上最后到达的那个节点开始，沿着查找路径向左向上回溯，类似于爬楼梯的过程。我们假设当回溯到某个节点的时候，它才被插入，这虽然相当于改变了节点的插入顺序，但从统计上不影响整个skiplist的形成结构。

现在假设我们从一个层数为i的节点x出发，需要向左向上攀爬k层。这时我们有两种可能：

- 如果节点x有第(i+1)层指针，那么我们需要向上走。这种情况概率为p。
- 如果节点x没有第(i+1)层指针，那么我们需要向左走。这种情况概率为(1-p)。

![分步查找](/img/跳跃表/分步查找.png)

用C(k)表示向上攀爬k个层级所需要走过的平均查找路径长度（概率期望），那么：

C(0)=0
C(k)=(1-p)×(上图中情况b的查找长度) + p×(上图中情况c的查找长度)
代入，得到一个差分方程并化简：

C(k)=(1-p)(C(k)+1) + p(C(k-1)+1)
C(k)=1/p+C(k-1)
C(k)=k/p
这个结果的意思是，我们每爬升1个层级，需要在查找路径上走1/p步。而我们总共需要攀爬的层级数等于整个skiplist的总层数-1。

那么接下来我们需要分析一下当skiplist中有n个节点的时候，它的总层数的概率均值是多少。这个问题直观上比较好理解。根据节点的层数随机算法，容易得出:

- 第1层链表固定有n个节点；
- 第2层链表平均有n*p个节点；
- 第3层链表平均有n*p2个节点；
- ......

所以，从第1层到最高层，各层链表的平均节点数是一个指数递减的等比数列。容易推算出，总层数的均值为log1/pn，而最高层的平均节点数为1/p。
综上，粗略来计算的话，平均查找长度约等于：

C(log1/pn-1)=(log1/pn-1)/p
即，平均时间复杂度为O(log n)。

当然，这里的时间复杂度分析还是比较粗略的。比如，沿着查找路径向左向上回溯的时候，可能先到达左侧头结点，然后沿头结点一路向上；还可能先到达最高层的节点，然后沿着最高层链表一路向左。但这些细节不影响平均时间复杂度的最后结果。另外，这里给出的时间复杂度只是一个概率平均值，但实际上计算一个精细的概率分布也是有可能的。

## 跳跃表与平衡树、哈希表的比较

- skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。

- 在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。

- 平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。

- 从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。

- 查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。

- 从算法实现难度上来比较，skiplist比平衡树要简单得多。

## Redis中跳跃表实现

### 节点的定义

**源码位置**

`server.h zskiplistNode`

**源码实现**

```c
typedef struct zskiplistNode {
    sds ele; //数据的值
    double score;   //分值
    struct zskiplistNode *backward; //后退指针
    //层信息
    struct zskiplistLevel {
        struct zskiplistNode *forward;  //前进指针
        unsigned long span; //跨度
    } level[];
} zskiplistNode;
```

**层(level)**

跳跃表节点的 level 数组可以包含多个元素， 每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， 层的数量越多， 访问其他节点的速度就越快。

每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （power law，越大的数出现的概率越小） 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小， 这个大小就是层的“高度”。随机层数生成算法参见跳跃表原理部分 : [生成随机层数的计算公式](#生成随机层数的计算公式)

### 前进指针

每个层都有一个指向表尾方向的前进指针（level[i].forward 属性）， 用于从表头向表尾方向访问节点。

示例 : `用虚线表示出了程序从表头向表尾方向， 遍历跳跃表中所有节点的路径`

![跳跃表迭代示例](/img/跳跃表/跳跃表迭代示例.png)

- 迭代程序首先访问跳跃表的第一个节点（表头）， 然后从第四层的前进指针移1. 动到表中的第二个节点。
- 在第二个节点时， 程序沿着第二层的前进指针移动到表中的第三个节点。
- 在第三个节点时， 程序同样沿着第二层的前进指针移动到表中的第四个节点。
- 当程序再次沿着第四个节点的前进指针移动时， 它碰到一个 NULL ， 程序知道这时已经到达了跳跃表的表尾， 于是结束这次遍历。

### 后退指针

节点的后退指针（backward 属性）用于 **从表尾向表头方向** 访问节点： 跟可以一次跳过多个节点的前进指针不同， 因为 **每个节点只有一个后退指针**， 所以每次只能后退至前一个节点。

示例 : `用虚线展示了从表尾向表头遍历跳跃表中的所有节点`

![从表尾向表头方向遍历跳跃表](/img/跳跃表/从表尾向表头方向遍历跳跃表.png)

- 程序首先通过跳跃表的 tail 指针访问表尾节点
- 通过后退指针访问倒数第二个节点、倒数第三个节点、直到倒退指针为NULL

### 跨度

层的跨度（level[i].span 属性）用于 **记录两个节点之间的距离**, 两个节点之间的跨度越大,相距得就越远

示例 : `用虚线标记了在跳跃表中查找分值为 3.0 、 成员对象为 o3 的节点时， 沿途经历的层`

![计算节点排位](/img/跳跃表/计算节点排位.png)

> [!TIP|style:flat|label:知识点]

> 1. 指向 NULL 的所有前进指针的跨度都为 **0** ， 因为它们没有连向任何节点。

> 2. 跨度和遍历操作 **无关**，遍历操作只关注前进指针

> 3. 跨度实际上是用来 **计算排位（rank）** 的： 在查找某个节点的过程中， 将沿途访问过的 **所有层的跨度累计** 起来， 得到的结果就是目标节点在跳跃表中的排位。

### 分值和成员

节点的分值（score 属性）是一个 **double类型** 的浮点数， 跳跃表中的所有节点都按 **分值从小到大** 来排序。

节点的成员对象 **ele** 保存了当前节点存储的值。

> [!TIP|style:flat|label:知识点]

> 1. 同一个跳跃表中， 各个节点保存的成员对象(ele)必须是 **唯一的**

> 2. 多个节点保存的 **分值却可以是相同的**

> 3. 分值相同的节点将按照 **字典序** 进行排序

### 跳跃表的实现

**源码定义**

```c
typedef struct zskiplist {
    struct zskiplistNode *header, *tail;    //表头节点和表尾节点
    unsigned long length;                   //表中节点数量
    int level;                              //表中最大的节点层数
} zskiplist;
```

- header 和 tail 指针分别指向跳跃表的表头和表尾节点， 通过这两个指针， 程序定位表头节点和表尾节点的复杂度为 O(1) 。
- 通过使用 length 属性来记录节点的数量， 程序可以在 O(1) 复杂度内返回跳跃表的长度。
- level 属性则用于在 O(1) 复杂度内获取跳跃表中层高最大的那个节点的层数量， 注意表头节点的层高并不计算在内。

### 跳跃表的API

函数 | 作用 | 时间复杂度
:-: | :-: | :-:
`zslCreate` | 创建一个新的跳跃表 | O(1)
`zslFree`	| 释放给定跳跃表，以及表中包含的所有节点。| O(N) ， N 为跳跃表的长度。
`zslInsert` | 将包含给定成员和分值的新节点添加到跳跃表中。| 平均 O(log N) ，最坏 O(N)， N 为跳跃表长度。
`zslDelete` | 删除跳跃表中包含给定成员和分值的节点。	| 平均 O(log N) ，最坏 O(N)， N 为跳跃表长度。
`zslGetElementByRank` | 返回跳跃表在给定排位上的节点。| 平均 O(log N) ，最坏 O(N)， N 为跳跃表长度。
`zslIsInRange` | 给定一个分值范围（range）， 比如 0 到 15 ， 20 到 28，诸如此类， 如果给定的分值范围包含在跳跃表的分值范围之内， 那么返回 1 ，否则返回 0 。| 通过跳跃表的表头节点和表尾节点， 这个检测可以用 O(1) 复杂度完成。
`zslFirstInRange`	 | 给定一个分值范围， 返回跳跃表中第一个符合这个范围的节点。|平均 O(log N) ，最坏 O(N)， N 为跳跃表长度。
`zslLastInRange` |给定一个分值范围， 返回跳跃表中最后一个符合这个范围的节点 | 平均 O(log N) ，最坏 O(N)， N 为跳跃表长度。
`zslDeleteRangeByScore`|给定一个分值范围， 删除跳跃表中所有在这个范围之内的节点。	|O(N) ， N 为被删除节点数量。
`zslDeleteRangeByRank`|给定一个排位范围， 删除跳跃表中所有在这个范围之内的节点。|O(N) ， N 为被删除节点数量。


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<div id="gitalk-container"></div>
<script>
var gitalk = new Gitalk({
  "clientID": "3e604fe69a5d3b9eec04",
  "clientSecret": "a220c4bd2b95f5f5ff70e7922f575c1e514dd986",
  "repo": "study-note",
  "owner": "go-developer",
  "admin": ["go-developer"],
  "id": "跳跃表skiplist原理及实现",      
  "distractionFreeMode": false  
});
gitalk.render("gitalk-container");
</script>
