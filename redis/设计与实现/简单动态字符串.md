# redis 字符串的实现(SDS)

## 源码中位置

`sds.h` `sds.c` `sdsalloc.h`

## SDS(Simple Dynamic String)定义
源码中定义 :

```c
typedef char *sds;
```

> [!TIP|style:flat|label:总结] sds类型实际为 char * 的别名,这样做的好处是，可以复用很多C的原生函数库。


## SDS的结构体定义sdshdr

sdshdr有好`五个`类别，它们分别是：`sdshdr5`，`sdshdr8`，`sdshdr16`，`sdshdr32`，`sdshdr64`，其中sdshdr5是不使用的

```c
/* Note: sdshdr5 is never used, we just access the flags byte directly. However is here to document the layout of type 5 SDS strings. */
struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* 已使用的长度(字符串真实长度) */
    uint8_t alloc; /* 字符串最大容量,不包含字符串的结尾 \0 */
    unsigned char flags; /* 总是占用一个字节。其中的最低3个bit用来表示header的类型,剩余5位未使用 */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len; /* 已使用的长度(字符串真实长度) */
    uint16_t alloc; /* 字符串最大容量,不包含字符串的结尾 \0 */
    unsigned char flags; /* 总是占用一个字节。其中的最低3个bit用来表示header的类型,剩余5位未使用 */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len; /* 已使用的长度(字符串真实长度) */
    uint32_t alloc; /* 字符串最大容量,不包含字符串的结尾 \0 */
    unsigned char flags; /* 总是占用一个字节。其中的最低3个bit用来表示header的类型,剩余5位未使用 */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len; /* 已使用的长度(字符串真实长度) */
    uint64_t alloc; /* 字符串最大容量,不包含字符串的结尾 \0 */
    unsigned char flags; /* 总是占用一个字节。其中的最低3个bit用来表示header的类型,剩余5位未使用 */
    char buf[];
};
```

> [!TIP|style:flat|label:结构体说明]
> len : 字符串的长度

> alloc : 字符串的容量

> flags : 用低三位表示header类型,高五位未使用,为何是低三位表示,见下方

> buf[] : 实际存储的字符串

**细节说明**

> [!NOTE|style:flat|label:attribute ((packed))]
> attribute ((packed))实际作用是 ** 取消编译阶段的内存优化对齐功能。 **

> 例如：struct aa {char a; int b;}; sizeof(aa) == 8;但是struct attribute ((packed)) aa {char a; int b;}; sizeof(aa) == 5;

>这个很重要，redis源码中不是直接对sdshdr某一个类型操作，往往参数都是sds，而sds就是结构体中的buf，在后面的源码分析中，你可能会经常看见s[-1]这种魔法一般的操作，而按照sdshdr内存分布s[-1]就是sdshdr中flags变量，由此可以获取到该sds指向的字符串的类型。

** sds类型的常量定义 **

```c
#define SDS_TYPE_5  0
#define SDS_TYPE_8  1
#define SDS_TYPE_16 2
#define SDS_TYPE_32 3
#define SDS_TYPE_64 4
#define SDS_TYPE_MASK 7
#define SDS_TYPE_BITS 3
```

> [!TIP|style:flat|label:为何是低三位表示类型]
> SDS_TYPE只占用了0,1,2,3,4五个数字，正好占用三位，我们就可以使用flags&SDS_TYPE_MASK来获取动态字符串对应的字符串类型


## SDS中的宏定义函数

**根据指向buf的sds变量s,得到sdshdr对应的指针变量**
```c
#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));
```

**根据指向buf的sds变量s,得到sdshdr对应的指针地址**
```c
#define SDS_HDR(T,s) ((struct sdshdr##T \*)((s)-(sizeof(struct sdshdr##T))));
```

**获取sdshdr5字符串类型的长度**
```c
#define SDS_TYPE_5_LEN(f) ((f)>>SDS_TYPE_BITS)
```


> [!NOTE|style:flat|label:c中的##语法]
> \#\# 是c语言中的连接符, 前加 \#\# 或者后加 ## 将标记作为一个合法的标识符的一部分，不是字符串．多用于多行的宏定义中。
> 本宏声明中,SDS_HDR_VAR(8,s) 相当于 struct sdshdr8 \*sh = (void\*)((s)-(sizeof(struct sdshdr8)));
