# redis 内存管理

## 内存回收

### 内存管理方案

因为 C 语言并不具备自动的内存回收功能，所以 Redis 在自己的对象系统中构建了一个 **引用计数（reference counting）** 技术实现的内存回收机制， 通过这一机制， 程序可以通过跟踪对象的引用计数信息， 在适当的时候自动释放对象并进行内存回收。

每个对象的引用计数信息由 redisObject 结构的 **refcount** 属性记录, 对象的引用计数信息会随着 **对象的使用状态** 而不断变化:

- 在创建一个新对象时， 引用计数的值会被 **初始化为 1**
- 当对象被一个新程序使用时， 它的引用计数值会被 **增 1**
- 当对象不再被一个程序使用时， 它的引用计数值会被 **减 1**
- 当对象的引用计数值变为 0 时， 对象所占用的内存会被释放

### 引用计数API

函数 | 作用
:-:|:-:
incrRefCount | 将对象的引用计数值增 1
decrRefCount | 将对象的引用计数值减 1， 当对象的引用计数值等于 0 时， 释放对象
resetRefCount | 将对象的引用计数值设置为 0 ， 但并不释放对象， 这个函数通常在需要重新设置对象的引用计数值时使用

## 对象共享

除了用于实现引用计数内存回收机制之外， 对象的引用计数属性还带有 **对象共享** 的作用。

举例,现在已有键A,存储值为 zhangdeman.现在新添加键B,存储值也为 zhangdeman,通常有两种做法:
- 为键 B 新创建一个包含整数值 zhangdeman 的字符串对象
- 让键 A 和键 B 共享同一个字符串对象

很明显贡献字符串对象更加节约内存,共享对象越多，节约的内存也越多

> [!TIP|style:flat|label:知识点]
> - Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 0 到 9999 的所有整数值， 当服务器需要用到值为 0 到 9999 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。
> - 创建共享字符串对象的数量可以通过修改 redis.h/REDIS_SHARED_INTEGERS 常量来修改,没有配置选型支持,修改后只能重新编译源码生效.
> - 共享对象不单单只有字符串键可以使用， 那些在数据结构中嵌套了字符串对象的对象（linkedlist 编码的列表对象、 hashtable 编码的哈希对象、 hashtable 编码的集合对象、以及 zset 编码的有序集合对象）都可以使用这些共享对象

## 对象空转时长

redisObject 结构包含一个 **lru** 属性， 该属性记录了 **对象最后一次被命令程序访问的时间**

键的空转时长 = 当前时间 - 键最后一次被程序访问的时间

```
**[terminal]
**[prompt zhangdeman@redis]**[path  ~]**[delimiter  $ ]**[command redis-cli
127.0.0.1:6379> SET msg "hello world"
OK
127.0.0.1:6379> OBJECT IDLETIME msg
(integer) 11
127.0.0.1:6379> OBJECT IDLETIME msg
(integer) 36
127.0.0.1:6379> GET msg
"hello world"
127.0.0.1:6379> OBJECT IDLETIME msg
(integer) 0
127.0.0.1:6379>]
```

> [!TIP|style:flat|label:知识点]
> **OBJECT IDLETIME** 用于获取一个键的空转时长
> **OBJECT IDLETIME** 实现是特殊的， 这个命令在访问键的值对象时， **不会修改值对象的 lru 属性**。
> 键的空转时长还有另外一项作用: 如果服务器打开了 **maxmemory** 选项， 并且服务器用于回收内存的算法为 **volatile-lru** 或者 **allkeys-lru** ， 那么当服务器占用的内存数超过了 **maxmemory** 选项所设置的上限值时， **空转时长较高** 的那部分键会优先被服务器释放， 从而回收内存。

<script>
var pageId = "redis内存管理"
</script>

!INCLUDE "../../common/gitalk.html"
