# redis对象

## 对象的类型与编码

### 对象

- Redis 使用 **对象** 来表示数据库中的键和值
- 在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。

### 对象的数据结构

**代码位置** : `server.h`

```c
typedef struct redisObject {
    unsigned type:4;        //4位记录数据类型
    unsigned encoding:4;    //4位记录编码方式
    unsigned lru:LRU_BITS;  //表示对象最后一次被命令程序访问的时间
    int refcount;           //引用计数
    void *ptr;              //实际存储数据的指针
} robj;
```

- `type` : 4位记录数据类型
- `encoding` : 4位记录编码方式
- `lru` : 表示对象最后一次被命令程序访问的时间
- `refcount` : 引用计数
- `*ptr` : 实际存储数据的指针

### 对象类型

对象的 type 属性记录了对象的类型， 这个属性的值可以是如下值:

`REDIS_STRING` : **字符串对象**

`REDIS_LIST` : **列表对象**

`REDIS_HASH` : **哈希对象**

`REDIS_SET` : **集合对象**

`REDIS_ZSET` : **有序集合对象**

对于 Redis 数据库保存的键值对来说，**键总是一个字符串对象**， 而值则可以是 **上述的任何一种**,因此，有如下说法:

- 当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键所对应的值为字符串对象”
- 当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键所对应的值为列表对象”
- 使用 **type** 命令可查看一个键对应的值的数据类型

**对象类型示例**
![有序链表](/img/redis/对象/值对象类型示例.png)

### 对象编码与实现

对象的 **ptr 指针** 指向对象的底层实现数据结构， 而这些数据结构由对象的 **encoding** 属性决定。

**对象编码列表**

编码常量 | 编码所对应的底层数据结构
:-: | :-:
REDIS_ENCODING_INT | 	long 类型的整数
REDIS_ENCODING_EMBSTR | 	embstr 编码的简单动态字符串
REDIS_ENCODING_RAW | 	简单动态字符串
REDIS_ENCODING_HT | 	字典
REDIS_ENCODING_LINKEDLIST | 	双端链表
REDIS_ENCODING_ZIPLIST | 压缩列表
REDIS_ENCODING_INTSET | 整数集合
REDIS_ENCODING_SKIPLIST	 | 跳跃表和字典

**每种类型的对象都至少使用了两种不同的编码**, 下表为不同类型和编码的对象 :

类型 | 编码 | 对象
:-: | :-: | :-:
REDIS_STRING | 	REDIS_ENCODING_INT | 	使用整数值实现的字符串对象。
REDIS_STRING | 	REDIS_ENCODING_EMBSTR | 	使用 embstr 编码的简单动态字符串实现的字符串对象。
REDIS_STRING | 	REDIS_ENCODING_RAW | 	使用简单动态字符串实现的字符串对象。
REDIS_LIST | 	REDIS_ENCODING_ZIPLIST | 	使用压缩列表实现的列表对象。
REDIS_LIST | 	REDIS_ENCODING_LINKEDLIST | 	使用双端链表实现的列表对象。
REDIS_HASH | 	REDIS_ENCODING_ZIPLIST | 	使用压缩列表实现的哈希对象。
REDIS_HASH | 	REDIS_ENCODING_HT | 	使用字典实现的哈希对象。
REDIS_SET | 	REDIS_ENCODING_INTSET | 	使用整数集合实现的集合对象。
REDIS_SET | 	REDIS_ENCODING_HT | 	使用字典实现的集合对象。
REDIS_ZSET | 	REDIS_ENCODING_ZIPLIST | 	使用压缩列表实现的有序集合对象。
REDIS_ZSET | 	REDIS_ENCODING_SKIPLIST	 | 使用跳跃表和字典实现的有序集合对象。

使用 **OBJECT ENCODING 命令** 可以查看一个数据库键的值对象的编码, 下表为对不同编码的输出 :

对象所使用的底层数据结构 | 编码常量 | 	OBJECT ENCODING 命令输出
:-: | :-: | :-:
整数 | 	REDIS_ENCODING_INT | 	"int"
embstr |  编码的简单动态字符串（SDS）	REDIS_ENCODING_EMBSTR | 	"embstr"
简单动态字符串 | 	REDIS_ENCODING_RAW | 	"raw"
字典 | 	REDIS_ENCODING_HT | 	"hashtable"
双端链表 | 	REDIS_ENCODING_LINKEDLIST | 	"linkedlist"
压缩列表 | 	REDIS_ENCODING_ZIPLIST | 	"ziplist"
整数集合 | 	REDIS_ENCODING_INTSET | 	"intset"
跳跃表和字典 | 	REDIS_ENCODING_SKIPLIST | 	"skiplist"

> [!TIP|style:flat|label:知识点]
> 不为特定类型的对象关联一种固定的编码， 极大地提升了 Redis 的 **灵活性和效率**， 因为 Redis 可以根据不同的使用场景来为一个对象设置不同的编码， 从而优化对象在某一场景下的效率
> 一个效率优化的例子:
- 列表对象包含的 **元素比较少** 时， Redis 使用 **压缩列表** 作为列表对象的底层实现,因为压缩列表比双端链表更 **节约内存**， 并且在元素数量较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以 **更快被载入到缓存中**
- 随着列表对象包含的元素越来越多， 使用压缩列表来保存元素的优势逐渐消失时， 对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的 **双端链表** 上面

<script>
var pageId = "redis对象的原理及实现"
</script>

!INCLUDE "../../common/gitalk.html"
