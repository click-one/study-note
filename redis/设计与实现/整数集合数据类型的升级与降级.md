# redis 整数集合数据类型的升级与降级

## 何时进行数据类型升级

每当我们要将一个新元素添加到整数集合里面， 并且 **新元素的类型比整数集合现有所有元素的类型都要长** 时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。

## 数据类型升级步骤

- 根据新元素的类型， **扩展整数集合底层数组的空间大小**， 并为新元素分配空间。
- 将底层数组 **现有的所有元素都转换成与新元素相同的类型**， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。
- 将新元素添加到底层数组里面。

## 一个数据升级的例子

**假设现在有一个 INTSET_ENC_INT16 编码的整数集合， 集合中包含三个 int16_t 类型的元素**

![int16_t类型的整数集合](/img/redis/整数集合/int16_t类型的整数集合.png)

**内存分布如下**

![int16_t类型整数集合内存分布](/img/redis/整数集合/int16_t整数集合内存分布.png)

**新增int32_t类型数据65535**

- 对比元素类型长度,类型 int32_t 比整数集合当前所有元素的类型都要长,所以在添加到整数集合之前，程序需要先对整数集合进行升级。
- 根据新类型的长度,以及集合元素的数量（包括要添加的新元素在内）， 对底层数组进行空间重分配。
- 原有数据（本例中指 1、2、3）类型升级(int16_t升级成int32_t)
- 添加新元素（65535）
- 修改整数集合 encoding 属性的值(int16_t -> int32_t)

> 空间重新分配后的内存结构

![空间重新分配后的内存结构](/img/redis/整数集合/空间重新分配后的内存结构.png)

> 类型转换

![对元素3进行类型转换](/img/redis/整数集合/对元素3进行类型转换.png)
![对元素2进行类型转换](/img/redis/整数集合/对元素2进行类型转换.png)

> 添加新元素

![添加新元素](/img/redis/整数集合/添加新元素.png)

> 修改数据类型

![修改数据类型标示](/img/redis/整数集合/修改数据类型标示.png)

> [!TIP|style:flat|label:知识点]
> 因为 **每次向整数集合添加新元素都可能会引起升级**， 而每次升级都需要对底层数组中已有的所有元素进行类型转换， 所以向整数集合添加新元素的 **时间复杂度为 O(N)**
> 引发升级的新元素的长度总是比整数集合现有所有元素的长度都大,所以新增加元素,要么最大,要么最小

## 类型升级的好处

### 提升灵活性

因为 C 语言是静态类型语言， 为了避免类型错误， 我们通常不会将两种不同类型的值放在同一个数据结构里面。

比如说， 我们一般只使用 int16_t 类型的数组来保存 int16_t 类型的值， 只使用 int32_t 类型的数组来保存 int32_t 类型的值， 诸如此类。

但是， 因为整数集合可以通过自动升级底层数组来适应新元素， 所以我们可以随意地将 int16_t 、 int32_t 或者 int64_t 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。

### 节约内存

要让一个数组可以同时保存 int16_t 、 int32_t 、 int64_t 三种类型的值， 最简单的做法就是直接使用 int64_t 类型的数组作为整数集合的底层实现。 不过这样一来， 即使添加到整数集合里面的都是 int16_t 类型或者 int32_t 类型的值， 数组都需要使用 int64_t 类型的空间去保存它们， 从而出现浪费内存的情况。

而整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以 **确保升级操作只会在有需要的时候进行**， 这可以尽量节省内存。

## 类型降级

整数集合 **不支持降级操作**， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。以上述例子为例,添加65535后，即使再将其删除,数据类型依旧位 int32_t
